## 1、内存共享与回收
* Redis在自己的对象系统中构建了一个`引用计数器技术`来实现内存回收机制
* 对象的`引用计数refcount`信息会随着对象的使用状态而不断变化，当refcount为`0`时会在适当的时候被回收
* 引用计数器的问题：对象间`循环引用`会导致无法释放对象。但是可以通过`del命令`主动删除，或指定一个`过期时间`被动删除
* redis只对包含整数值的字符串对象进行`共享`，Redis在初始化服务器时，会创建一万个共享字符串对象，如"0", "1", ..., "9999"
---
## 2、过期键的删除策略
* Redis的过期键删除策略：`惰性删除` + `定期删除`
* `定时删除`和`定期删除`属于`主动删除`，`惰性删除`属于`被动删除`
* 1、定时删除
  * 在设置KEY的过期时间的同时，还创建了一个`定时器（timer）`，让定时器在键的过期时间来临时，立即执行对KEY的删除操作。
  * 对内存是最友好的，对CPU时间是最不友好的
* 2、定期删除
  * 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。
  * 兼顾了内存和CPU时间，但是很难确定执行删除操作的`时长`和`频率`
* 3、惰性删除
  * 每次从`键空间`中获取键时，都检查取得的键是否过期，如果过期的话就删除，否则就返回该键
  * 对内存是最不友好的，对CPU时间是最友好的
---
## 3、内存淘汰策略
```
# 设置最大的内存，如果不设置该值的话，会导致redis一直运行最终以内存不足而终止
# maxmemory <bytes>
```
* Redis每执行一个命令，就会判断当前占用的内存是否大于设置的最大内存，大于，则开始内存淘汰机制。
* Redis内存淘汰的机制有以下几种方案可供选择

|名称|详解|
|:---|:---|
|noeviction|拒绝写操作， 读、删除可以正常使用。默认策略，不建议使用|
|allkeys-lru|移除最近最少使用的key，最常用的策略|
|allkeys-random|随机删除某个key，不建议使用|
|volatile-lru|在设置了过期时间的key中，移除最近最少使用的key，不建议使用|
|volatile-random|在设置了过期时间的key中，随机删除某个key，不建议使用|
|volatile-ttl|在设置了过期时间的key中，把最早要过期的key优先删除|
### 4、LRU算法
```java
public class LRUCache<K,V> extends LinkedHashMap<K,V> {
    private int cacheSize;
    
    public LRUCache(int cacheSize){
        super(10, 0.75f, true);
        //设置hashmap大小，true是让linkedhashmap按照访问顺序排序
        this.cacheSize = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        //当map中数量大于指定缓存个数的时候，自动删除最老的数据
        return size()>cacheSize;
    }
}

```