## 1、内存共享与回收
* Redis在自己的对象系统中构建了一个`引用计数器技术`来实现内存回收机制
* 对象的`引用计数refcount`信息会随着对象的使用状态而不断变化，当refcount为`0`时会在适当的时候被回收
* 引用计数器的问题：对象间`循环引用`会导致无法释放对象。但是可以通过`del命令`主动删除，或指定一个`过期时间`被动删除
* redis只对包含整数值的字符串对象进行`共享`，Redis在初始化服务器时，会创建一万个共享字符串对象，如"0", "1", ..., "9999"
---
## 2、过期键的删除策略
* Redis的过期键删除策略：`惰性删除` + `定期删除`
* `定时删除`和`定期删除`属于`主动删除`，`惰性删除`属于`被动删除`
* 1、定时删除
  * 在设置KEY的过期时间的同时，还创建了一个`定时器（timer）`，让定时器在键的过期时间来临时，立即执行对KEY的删除操作。
  * 对内存是最友好的，对CPU时间是最不友好的
* 2、定期删除
  * 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。
  * 兼顾了内存和CPU时间，但是很难确定执行删除操作的`时长`和`频率`
* 3、惰性删除
  * 每次从`键空间`中获取键时，都检查取得的键是否过期，如果过期的话就删除，否则就返回该键
  * 对内存是最不友好的，对CPU时间是最友好的
---
## 3、内存淘汰策略
```
# 设置最大的内存，如果不设置该值的话，会导致redis一直运行最终以内存不足而终止
# maxmemory <bytes>
```
* Redis每执行一个命令，就会判断当前占用的内存是否大于设置的最大内存，大于，则开始内存淘汰机制。
* Redis内存淘汰的机制有以下`6种方案`可供选择

|次序|名称|详解|---|
|:---|:---|:---|:---|
|1|volatile-lru|从已设置过期时间的数据集中挑选最近最少使用的数据淘汰|不建议使用|
|2|volatile-random|从已设置过期时间的数据集中任意选择数据淘汰|不建议使用|
|3|volatile-ttl|从已设置过期时间的数据集中挑选将要过期的数据淘汰|
|4|allkeys-lru|从所有数据集中挑选最近最少使用的数据淘汰|最常用的策略|
|5|allkeys-random|从所有数据集中任意选择数据进行淘汰|不建议使用|
|6|noeviction|禁止驱逐数据|默认策略，不建议使用|

* 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有key，
  而是抽样一小部分并且从中选出被淘汰的 key。
* 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。
  可以将内存最大使用量设置为热点数据占用的内存量，然后启用`allkeys-lru淘汰策略`，将最近最少使用的数据淘汰。
* Redis 4.0 引入了 `volatile-lfu`和 `allkeys-lfu`淘汰策略，LFU策略通过统计访问频率，将访问
  频率最少的键值对淘汰。
### 4、LRU算法
```java
public class LRUCache<K,V> extends LinkedHashMap<K,V> {
    private int cacheSize;
    
    public LRUCache(int cacheSize){
        super(10, 0.75F, true);
        //设置hashmap大小，true是让linkedhashmap按照访问顺序排序
        this.cacheSize = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        //当map中数量大于指定缓存个数的时候，自动删除最老的数据
        return size()>cacheSize;
    }
}
```