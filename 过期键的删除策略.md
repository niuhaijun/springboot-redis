## 1、内存回收
* Redis在自己的对象系统中构建了一个`引用计数器技术`来实现内存回收机制
* 对象的`引用计数refcount`信息会随着对象的使用状态而不断变化，当refcount为`0`时会在适当的时候被回收
* 引用计数器的问题：对象间`循环引用`会导致无法释放对象
* redis只对包含整数值的字符串对象进行`共享`，Redis在初始化服务器时，会创建一万个共享字符串对象，如"0", "1", ..., "9999"
---
## 2、过期键的删除策略
* Redis的过期键删除策略：`惰性删除` + `定期删除`
* `定时删除`和`定期删除`属于`主动删除`，`惰性删除`属于`被动删除`
* 1、定时删除
  * 在设置KEY的过期时间的同时，还创建了一个`定时器（timer）`，让定时器在键的过期时间来临时，立即执行对KEY的删除操作。
  * 对内存是最友好的，对CPU时间是最不友好的
* 2、定期删除
  * 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。
  * 兼顾了内存和CPU时间，但是很难确定执行删除操作的`时长`和`频率`
* 3、惰性删除
  * 每次从`键空间`中获取键时，都检查取得的键是否过期，如果过期的话就删除，否则就返回该键
  * 对内存是最不友好的，对CPU时间是最友好的
---
## 3、`rbd`对过期键的处理
* 生成rdb文件：执行save命令和bgsave命令创建一个新rbd文件时，已过期的键不会被保存到新创建的rdb文件中
* 载入rdb文件：启动redis时，服务器开启了rdb功能，服务器将载入rdb文件
    * 服务器以`主服务器模式`运行，载入rdb文件时，程序只会保留未过期的键
    * 服务器以`从服务器模式`运行，载入rdb文件时，程序会保留所有键。主从服务器在进行数据同步的时候，从服务器的数据库会被清空。
---
## 4、aof对过期键的处理
* aof文件写入：当过期键被删除时，程序回向aof文件追加一条del命令，显示记录该键被删除
* aof重写：在执行aof重写的过程中，
---

## 5、复制功能对过期键的处理
---

