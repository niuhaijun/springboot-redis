# 字典数据结构

## 1、基础知识
* Redis的`数据库`的底层实现`字典`
* `字典`的底层实现是`哈希表`
* 使用`链地址法`解决hash冲突
* 字典中有2个哈希表：`ht[0]`和`ht[1]`
---
## 2、rehash（重新散列）
* 目的：通过`扩展`和`收缩`操作将哈希表的`负载因子`维持在合理的范围内。
* 负载因子公式：
  * 负载因子 = 哈希表已保存的节点数（K-V总数） / 哈希表大小
  * load_factory = ht[0].used / ht[0].size
* rehash步骤
  * 1、分配空间：为ht[1]哈希表分配空间
    * 扩展操作：ht[1]的大小为第一个大于等于 `ht[0].used * 2` 的 `2^n`
    * 收缩操作：ht[1]的大小为第一个大于等于 `ht[0].used` 的 `2^n`
  * 2、迁移节点：将ht[0]中的所有键值对rehash到ht[1]
  * 3、释放空间：键值对迁移完成后，ht[1]设置为ht[0],并未ht[1]创建一个空白哈希表
---
## 3、哈希表扩展与收缩的触发条件
* 触发扩展的条件(满足一种即可)
  * 1、Redis`没有执行`bgsave或者bgrewriteaof命令，且load_factory >= 1
  * 2、Redis`正在执行`bgsave或者bgrewriteaof命令，且load_factory >= 1 >= 5
* 触发收缩的条件
  * load_factory < 0.1
---
## 4、哈希表扩容时设置不同负载因子的目的是什么？
  * 目的是：节约内存
  * 原理
    * 执行bgsave和bgrewriteaof命令时，Redis会创建一个服务器进程的子进程
    * 多数OS会采用`写时复制（copy-on-write）`技术提高子进程的使用率
    * 在子进程存在期间，如果load_factory偏小，就容易触发哈希表扩容操作，造成不必要的内存写入操作，浪费内存空间
---
## 5、哈希表渐进式rehash的步骤
* 1、为ht[1]分配空间，让字典表同时持有`ht[0]`和`ht[1]`这两个哈希表
* 2、在字典表中维持一个`索引计数器变量rehashidx`，并设置为`0`，表示rehash工作正式开始
* 3、在rehash期间，每次对字典表执行CRUD操作，程序不仅会完成指定的操作，还会将rehashindex索引上的所有键值对rehash到ht[1]，当rehash执行完成以后，程序将rehashidx属性值加`1`
* 4、随着对字典操作的增加，ht[0]上的键值对最终都会被rehash到ht[1]，此时程序将rehashidx设置为`-1`，表示rehash操作已完成。
* 核心思想：
  * 一次操作，就rehash一个桶内的所有`键值对`
  * rehashidex为0，表示rehash开始；为-1表示rehash结束
---
## 6、内存回收
* Redis在自己的对象系统中构建了一个`引用计数器技术`来实现内存回收机制
* 对象的`引用计数refcount`信息会随着对象的使用状态而不断变化，当refcount为`0`时会在适当的时候被回收
* 引用计数器的问题：对象间`循环引用`会导致无法释放对象
* redis只对包含整数值的字符串对象进行共享,Redis在初始化服务器时，会创建一万个共享字符串对象，如"0", "1", ..., "9999"
---
## 7、过期键的删除策略
* 1、定时删除
  * 在设置KEY的过期时间的同时，还创建了一个`定时器（timer）`，让定时器在键的过期时间来临时，立即执行对KEY的删除操作。
  * 对内存是最友好的
  * 对CPU时间是最不友好的
* 2、定期删除
  * 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。
  * 
* 3、惰性删除
  * 每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除，否则就返回该键
  * 对内存是最不友好的
  * 对CPU时间是最友好的
--- 
