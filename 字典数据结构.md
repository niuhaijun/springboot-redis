## 1、基础知识
* Redis的`数据库`的底层实现`字典`
* `字典`的底层实现是`哈希表`
* 使用`链地址法`解决hash冲突
* 字典中有2个哈希表：`ht[0]`和`ht[1]`
---
## 2、rehash（重新散列）
* 目的：通过`扩展`和`收缩`操作将哈希表的`负载因子`维持在合理的范围内。
* 负载因子公式：
  * 负载因子 = 哈希表已保存的节点数（K-V总数） / 哈希表大小
  * load_factory = ht[0].used / ht[0].size
* rehash步骤
  * 1、分配空间：为ht[1]哈希表分配空间
    * 扩展操作：ht[1]的大小为第一个大于等于 `ht[0].used * 2` 的 `2^n`
    * 收缩操作：ht[1]的大小为第一个大于等于 `ht[0].used` 的 `2^n`
  * 2、迁移节点：将ht[0]中的所有键值对rehash到ht[1]
  * 3、释放空间：键值对迁移完成后，ht[1]设置为ht[0],并未ht[1]创建一个空白哈希表
---
## 3、哈希表扩展与收缩的触发条件
* 触发扩展的条件(满足一种即可)
  * 1、Redis`没有执行`bgsave或者bgrewriteaof命令，且load_factory >= 1
  * 2、Redis`正在执行`bgsave或者bgrewriteaof命令，且load_factory >= 5
* 触发收缩的条件
  * load_factory < 0.1
---
## 4、哈希表扩容时设置不同负载因子的目的是什么？
  * 目的是：节约内存
  * 原理
    * 执行bgsave和bgrewriteaof命令时，Redis会创建一个服务器进程的`子进程`
    * 多数OS会采用`写时复制（copy-on-write）`技术提高子进程的使用率
    * 在子进程存在期间，如果load_factory偏小，就容易触发哈希表扩容操作，造成不必要的内存写入操作，浪费内存空间
---
## 5、哈希表渐进式rehash的步骤
* 1、为ht[1]分配空间，让字典表同时持有`ht[0]`和`ht[1]`这两个哈希表
* 2、在字典表中维持一个`索引计数器变量rehashidx`，并设置为`0`，表示rehash工作正式开始
* 3、在rehash期间，每次对字典表执行CRUD操作，程序不仅会完成指定的操作，还会将rehashindex索引上的所有键值对rehash到ht[1]，当rehash执行完成以后，程序将rehashidx属性值加`1`
* 4、随着对字典操作的增加，ht[0]上的键值对最终都会被rehash到ht[1]，此时程序将rehashidx设置为`-1`，表示rehash操作已完成。
* 核心思想：
  * 一次操作，就rehash一个桶内的所有`键值对`
  * rehashidex为0，表示rehash开始；为-1表示rehash结束
