# 一：持久化
## 1、rdb持久化：通过保存数据库中的K-V实现
### 触发rbd持久化的方式
* 手动执行`save`和`bgsave`命令
  * `save命令`由服务器进程执行保存工作，会阻塞服务器
  * `bgsave命令`由子进程执行保存工作，不会阻塞服务器
* 配置服务器定期执行
  * 服务器配置`save`，用于设置保存条件
  * save选项默认配置：
    * save 900  1  服务器在900秒内，对数据库进行了至少1次修改
    * save 300 10
    * save 60 10000
    * 只要满足以上的任意一个条件，bgsave命令都会被执行
### 载入rbd文件的条件
* 启动服务器
* 未开启aof持久化功能
* 开启rdb持久化功能
### 与rbd持久化有关的数据库属性
* `dirty`：是一个计数器，记录距离上一次成功执行save命令或者bgsave命令之后，服务区对数据库状态修改的次数。
* `lastsvae`：是一个Unix时间戳，记录了服务器上一次成功执行save命令或者bgsave命令的时间
* 注意：redis服务器中有一个周期性执行的`serverCron函数`，默认每`100毫秒`执行一次，用于检查save选项所设置的保存条件是否已经满足，如果满足就执行bgsave命令
### rbd文件的结构
#### 总体结构
|`REDIS`|`db_version`|`database`|`EOF`|`check_sum`|
|--------|--------|--------|--------|--------|
* REDIS常量：5个字节，保存"redis"
* db_version：4个字节，rdb文件版本号
* database: 0 - N， 0到多个数据库
* EOF常量：1个字节，RDB正文结束标志位
* check_sum：8个字节，校验和
#### database结构
|`SELECTDB`|`db_number`|`key_value_pairs`|
|--------|--------|--------|
* SELECTDB常量：1字节，标志rdb下一部分内容是数据库号码 
* db_number：1，2，5字节，数据库号码
* key_value_pairs：数据库中所有键值对数据
#### key_value_pairs结构
|`TYPE`|`key`|`value`|
|--------|--------|--------|

|`EXPIRETIME_MS`|`ms`|`TYPE`|`key`|`value`|
|--------|--------|--------|--------|--------|
* `EXPIRETIME_MS常量`：1字节，标志下一部分内容是key的过期时间 
* `ms`：8字节，key的过期时间，Unix时间戳
* `TYPE`：1字节，value的类型
* `key`：字符串对象
* `value`：任意一种对象
#### 分析rdb文件
* `flushall`：清空数据库
* `save`：以阻塞的方式生成rdb文件
* `od -c dump.rdb`：以ascii编码的方式输出文件
* `od -x dump.rdb`：以16进制的方式输出文件
* `redis-check-dump`工具
---
## 2、aof持久化：通过保存写命令实现
### aof持久化的实现
* `命令追加`：将写命令保存到aof_buffer缓冲区的末尾
* `文件写入`：将aof_buffer缓冲区中的所有内容写入AOF文件（应该是内存缓冲区）
* `文件同步`：将内存缓冲区里面的写入数据同步到磁盘
### 3种aof同步策略
| --------- | appendfsync选项的值  | flushAppendOnlyFile函数的行为 |
| ---: | ---: | ---: |
| 每修改同步 | `always` | 将aof_buffer缓冲区中的所有内容写入到AOF文件，并同步AOF文件|
| 每秒同步 | `everysec` | 将aof_buffer缓冲区中的所有内容写入到AOF文件。如果距离上次同步aof文件的时间`超过1秒`，那么通过一个线程同步aof文件|
| 不同步 | no | 将aof_buffer缓存区中的所有内容写入到AOF文件。同步时间由OS决定|
### aof文件载入
Redis创建一个为客户端，从aof文件中逐条读取写命令并执行，直到所有的写命令被处理完毕。
### aof重写
* 随着时间的推移，aof文件记录的写命令会越来越多，导致文件越来越大。为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能，生成新的aof文件替代旧aof文件
* 命令：`bgrewriteaof`
* aof文件重写原理：
  * aof文件重写不需要对现有的aof文件进行任何读取、分析、写入操作。这个功能是通过读取服务器当前的数据库状态来实现的。
  * 首先从数据库中读取键现在的值，然后用一条命令去记录键值对，替代之前记录这个键值对的多条命令。
  * 通过使用一条命令替代多条命令的方式，减少写命令的个数，进而降低aof文件的大小
* aof重写时的服务器进程与子进程
  * Redis服务器使用`单线程`来处理命令请求
  * 如果使用服务器进程执行aof重写程序，会造成阻塞，重写aof文件期间无法处理客户端的请求
  * Redis使用子进程执行aof重写程序，同时达到了以下两个目的
    * 子进程进行aof重写期间，服务器进程正常处理请求
    * 子进程有服务器进程的数据副本，使用子进程而不是线程，可以避免在使用锁的情况下保证数据的安全性。
* 使用子进程执行aof重写带来的问题以及解决方法
  * 问题：`数据不一致`。重写后的aof文件与服务器当前的数据库状态不一致
  * 解决方案：将导致数据不一致的命令保存到`aof重写缓冲区`中
  * 方案细节：
    * Redis设置了一个aof重写缓冲区
    * 写命令不仅要追加到`aof缓冲区`，还要追加到`aof重写缓冲区`
    * 当子进程生成新的aof文件之后，服务器还会将重写缓冲区中的所有内容追加到新aof文件末尾
    * 此时，新旧aof文件所保存的数据库状态是一致的
    * 最后，服务器使用新文件替代旧文件，完成aof重写操作
---
# 二：持久化和复制功能对过期键的处理
## 1、`rbd`对过期键的处理
* 生成rdb文件：执行`save`命令和`bgsave`命令创建一个新rbd文件时，已过期的键不会被保存到新创建的rdb文件中
* 载入rdb文件：启动redis时，服务器开启了rdb功能，服务器将载入rdb文件
    * 服务器以`主服务器模式`运行，载入rdb文件时，程序只会保留未过期的键
    * 服务器以`从服务器模式`运行，载入rdb文件时，程序会保留所有键。主从服务器在进行数据同步的时候，从服务器的数据库会被清空。
---
## 2、`aof`对过期键的处理
* aof文件写入：当过期键被删除时，程序回向aof文件追加一条`del命令`，显示记录该键被删除
* aof重写：在执行aof重写时，已过期的键不会被保存到重写后的aof文件中
---
## 3、`复制`对过期键的处理：
* 当服务器运行在`复制模式`下时，从服务器的过期键删除动作由`主服务器`控制
* 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键；
* 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键；
* 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。
* 目的：主服务器控制从服务器统一删除过期键，保证主从服务器数据一致性。
## 4、总结
* 执行`save`命令或者`bgsave`命令，新生成的`rdb`文件不会包含已过期的键
* 执行`bgrewrite`命令，生成的重写`aof`文件不会保留已过期的键
* 当一个过期键被删除后，服务器会在aof文件的末尾追加一条del命令，显示删除过期键
* 主服务器控制从服务器统一删除过期键，这种统一、中心化的过期删除策略可以保证主从服务器数据一致性
## 5、过期命令
* `expire key ttl` ： 设置key的生存时长，时长为ttl秒
* `pexpire key ttl ： 设置key的生存时长，时长为ttl毫秒
* `expireat key timestamp` ： 设置key的过期时间点，过期时间点为timestamp秒时间戳
* `pexpireat key timestamp` ： 设置key的过期时间点，过期时间点为timestamp毫秒时间戳
* `persist key` ：删除过期时间
* `ttl key` ： 为秒为单位，返回键的剩余生存时间
* `pttl key` ：以毫秒为单位，返回键的剩余生存实际那
---